<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pandas.indexes.base &#8212; psst 0.1.1a documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/jsdemo.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/jsdemo.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/plotting.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="top" title="psst 0.1.1a documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>

<script type="text/javascript">
   console.log('Loading javascript')
</script>


  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pandas.indexes.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas.tslib</span> <span class="k">as</span> <span class="nn">tslib</span>
<span class="kn">import</span> <span class="nn">pandas.lib</span> <span class="k">as</span> <span class="nn">lib</span>
<span class="kn">import</span> <span class="nn">pandas._join</span> <span class="k">as</span> <span class="nn">_join</span>
<span class="kn">import</span> <span class="nn">pandas.algos</span> <span class="k">as</span> <span class="nn">_algos</span>
<span class="kn">import</span> <span class="nn">pandas.index</span> <span class="k">as</span> <span class="nn">_index</span>
<span class="kn">from</span> <span class="nn">pandas.lib</span> <span class="k">import</span> <span class="n">Timestamp</span><span class="p">,</span> <span class="n">Timedelta</span><span class="p">,</span> <span class="n">is_datetime_array</span>

<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="k">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">compat</span>


<span class="kn">from</span> <span class="nn">pandas.types.generic</span> <span class="k">import</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">,</span> <span class="n">ABCPeriodIndex</span>
<span class="kn">from</span> <span class="nn">pandas.types.missing</span> <span class="k">import</span> <span class="n">isnull</span><span class="p">,</span> <span class="n">array_equivalent</span>
<span class="kn">from</span> <span class="nn">pandas.types.common</span> <span class="k">import</span> <span class="p">(</span><span class="n">_ensure_int64</span><span class="p">,</span>
                                 <span class="n">_ensure_object</span><span class="p">,</span>
                                 <span class="n">_ensure_categorical</span><span class="p">,</span>
                                 <span class="n">_ensure_platform_int</span><span class="p">,</span>
                                 <span class="n">is_integer</span><span class="p">,</span>
                                 <span class="n">is_float</span><span class="p">,</span>
                                 <span class="n">is_dtype_equal</span><span class="p">,</span>
                                 <span class="n">is_object_dtype</span><span class="p">,</span>
                                 <span class="n">is_categorical_dtype</span><span class="p">,</span>
                                 <span class="n">is_bool_dtype</span><span class="p">,</span>
                                 <span class="n">is_integer_dtype</span><span class="p">,</span> <span class="n">is_float_dtype</span><span class="p">,</span>
                                 <span class="n">is_datetime64_any_dtype</span><span class="p">,</span>
                                 <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
                                 <span class="n">needs_i8_conversion</span><span class="p">,</span>
                                 <span class="n">is_iterator</span><span class="p">,</span> <span class="n">is_list_like</span><span class="p">,</span>
                                 <span class="n">is_scalar</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.types.cast</span> <span class="k">import</span> <span class="n">_coerce_indexer_dtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.common</span> <span class="k">import</span> <span class="p">(</span><span class="n">is_bool_indexer</span><span class="p">,</span>
                                <span class="n">_values_from_object</span><span class="p">,</span>
                                <span class="n">_asarray_tuplesafe</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="k">import</span> <span class="p">(</span><span class="n">PandasObject</span><span class="p">,</span> <span class="n">FrozenList</span><span class="p">,</span> <span class="n">FrozenNDArray</span><span class="p">,</span>
                              <span class="n">IndexOpsMixin</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.base</span> <span class="k">as</span> <span class="nn">base</span>
<span class="kn">from</span> <span class="nn">pandas.util.decorators</span> <span class="k">import</span> <span class="p">(</span><span class="n">Appender</span><span class="p">,</span> <span class="n">Substitution</span><span class="p">,</span> <span class="n">cache_readonly</span><span class="p">,</span>
                                    <span class="n">deprecate</span><span class="p">,</span> <span class="n">deprecate_kwarg</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.types.concat</span> <span class="k">as</span> <span class="nn">_concat</span>
<span class="kn">import</span> <span class="nn">pandas.core.missing</span> <span class="k">as</span> <span class="nn">missing</span>
<span class="kn">import</span> <span class="nn">pandas.core.algorithms</span> <span class="k">as</span> <span class="nn">algos</span>
<span class="kn">from</span> <span class="nn">pandas.formats.printing</span> <span class="k">import</span> <span class="n">pprint_thing</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="k">import</span> <span class="n">_comp_method_OBJECT_ARRAY</span>
<span class="kn">from</span> <span class="nn">pandas.core.strings</span> <span class="k">import</span> <span class="n">StringAccessorMixin</span>

<span class="kn">from</span> <span class="nn">pandas.core.config</span> <span class="k">import</span> <span class="n">get_option</span>

<span class="c1"># simplify</span>
<span class="n">default_pprint</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_seq_items</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> \
    <span class="n">pprint_thing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">escape_chars</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">quote_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">max_seq_items</span><span class="o">=</span><span class="n">max_seq_items</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Index&#39;</span><span class="p">]</span>

<span class="n">_unsortable_types</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="s1">&#39;mixed&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed-integer&#39;</span><span class="p">))</span>

<span class="n">_index_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s1">&#39;Index&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">unique</span><span class="o">=</span><span class="s1">&#39;Index&#39;</span><span class="p">,</span> <span class="n">duplicated</span><span class="o">=</span><span class="s1">&#39;np.ndarray&#39;</span><span class="p">)</span>
<span class="n">_index_shared_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_try_get_item</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>


<span class="k">class</span> <span class="nc">InvalidIndexError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">_o_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
<span class="n">_Identity</span> <span class="o">=</span> <span class="nb">object</span>


<span class="k">def</span> <span class="nf">_new_Index</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This is called upon unpickling, rather than the default which doesn&#39;t</span>
<span class="sd">    have arguments and breaks __new__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Index</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="p">,</span> <span class="n">StringAccessorMixin</span><span class="p">,</span> <span class="n">PandasObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Immutable ndarray implementing an ordered, sliceable set. The basic object</span>
<span class="sd">    storing axis labels for all pandas objects</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like (1-dimensional)</span>
<span class="sd">    dtype : NumPy dtype (default: object)</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Make a copy of input ndarray</span>
<span class="sd">    name : object</span>
<span class="sd">        Name to be stored in the index</span>
<span class="sd">    tupleize_cols : bool (default: True)</span>
<span class="sd">        When True, attempt to create a MultiIndex if possible</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    An Index instance can **only** contain hashable objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># To hand over control to subclasses</span>
    <span class="n">_join_precedence</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Cython methods</span>
    <span class="n">_arrmap</span> <span class="o">=</span> <span class="n">_algos</span><span class="o">.</span><span class="n">arrmap_object</span>
    <span class="n">_left_indexer_unique</span> <span class="o">=</span> <span class="n">_join</span><span class="o">.</span><span class="n">left_join_indexer_unique_object</span>
    <span class="n">_left_indexer</span> <span class="o">=</span> <span class="n">_join</span><span class="o">.</span><span class="n">left_join_indexer_object</span>
    <span class="n">_inner_indexer</span> <span class="o">=</span> <span class="n">_join</span><span class="o">.</span><span class="n">inner_join_indexer_object</span>
    <span class="n">_outer_indexer</span> <span class="o">=</span> <span class="n">_join</span><span class="o">.</span><span class="n">outer_join_indexer_object</span>
    <span class="n">_box_scalars</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_typ</span> <span class="o">=</span> <span class="s1">&#39;index&#39;</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_id</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">asi8</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_comparables</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
    <span class="n">_allow_index_ops</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_allow_datetime_index_ops</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_allow_period_index_ops</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_is_numeric_dtype</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_can_hold_na</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># prioritize current class for _shallow_copy_with_infer,</span>
    <span class="c1"># used to infer integers as datetime-likes</span>
    <span class="n">_infer_as_myclass</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_engine_type</span> <span class="o">=</span> <span class="n">_index</span><span class="o">.</span><span class="n">ObjectEngine</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">fastpath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">.range</span> <span class="k">import</span> <span class="n">RangeIndex</span>

        <span class="c1"># range</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">RangeIndex</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">range</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RangeIndex</span><span class="o">.</span><span class="n">from_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                         <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># categorical</span>
        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">.category</span> <span class="k">import</span> <span class="n">CategoricalIndex</span>
            <span class="k">return</span> <span class="n">CategoricalIndex</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># index-like</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
               <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span> <span class="ow">or</span>
               <span class="s1">&#39;tz&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                       <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">_o_dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_o_dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span>
                  <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))):</span>
                <span class="kn">from</span> <span class="nn">pandas.tseries.tdi</span> <span class="k">import</span> <span class="n">TimedeltaIndex</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">TimedeltaIndex</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_o_dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">to_pytimedelta</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_o_dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>

                    <span class="c1"># we need to avoid having numpy coerce</span>
                    <span class="c1"># things that look like ints/floats to ints unless</span>
                    <span class="c1"># they are actually ints, e.g. &#39;0&#39; and 0.0</span>
                    <span class="c1"># should not be coerced</span>
                    <span class="c1"># GH 11836</span>
                    <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                        <span class="n">inferred</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;floating&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed-integer-float&#39;</span><span class="p">]:</span>

                            <span class="c1"># if we are actually all equal to integers</span>
                            <span class="c1"># then coerce to integer</span>
                            <span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">Int64Index</span><span class="p">,</span> <span class="n">Float64Index</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                                    <span class="k">return</span> <span class="n">Int64Index</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                                      <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                                <span class="k">pass</span>

                            <span class="c1"># return an actual float index</span>
                            <span class="k">return</span> <span class="n">Float64Index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

                        <span class="k">elif</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                        <span class="n">inferred</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="k">pass</span>

            <span class="c1"># maybe coerce to a sub-class</span>
            <span class="kn">from</span> <span class="nn">pandas.tseries.period</span> <span class="k">import</span> <span class="p">(</span><span class="n">PeriodIndex</span><span class="p">,</span>
                                               <span class="n">IncompatibleFrequency</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">PeriodIndex</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">Int64Index</span>
                <span class="k">return</span> <span class="n">Int64Index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">Float64Index</span>
                <span class="k">return</span> <span class="n">Float64Index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">_asarray_tuplesafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

            <span class="c1"># _asarray_tuplesafe does not always copy underlying data,</span>
            <span class="c1"># so need to make sure that this happens</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">subarr</span> <span class="o">=</span> <span class="n">subarr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inferred</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">Int64Index</span>
                    <span class="k">return</span> <span class="n">Int64Index</span><span class="p">(</span><span class="n">subarr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                      <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;floating&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed-integer-float&#39;</span><span class="p">]:</span>
                    <span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">Float64Index</span>
                    <span class="k">return</span> <span class="n">Float64Index</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s1">&#39;boolean&#39;</span><span class="p">:</span>
                    <span class="c1"># don&#39;t support boolean explicity ATM</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">inferred</span> <span class="o">!=</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">inferred</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">is_datetime_with_singletz_array</span><span class="p">(</span><span class="n">subarr</span><span class="p">)</span> <span class="ow">or</span>
                                <span class="s1">&#39;tz&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
                            <span class="c1"># only when subarr has the same tz</span>
                            <span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                                     <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">except</span> <span class="n">tslib</span><span class="o">.</span><span class="n">OutOfBoundsDatetime</span><span class="p">:</span>
                                <span class="k">pass</span>

                    <span class="k">elif</span> <span class="n">inferred</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;timedelta&#39;</span><span class="p">):</span>
                        <span class="kn">from</span> <span class="nn">pandas.tseries.tdi</span> <span class="k">import</span> <span class="n">TimedeltaIndex</span>
                        <span class="k">return</span> <span class="n">TimedeltaIndex</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">inferred</span> <span class="o">==</span> <span class="s1">&#39;period&#39;</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">PeriodIndex</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">except</span> <span class="n">IncompatibleFrequency</span><span class="p">:</span>
                            <span class="k">pass</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;__array__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_scalar_data_error</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tupleize_cols</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)):</span>

                <span class="c1"># we must be all tuples, otherwise don&#39;t construct</span>
                <span class="c1"># 10697</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">data</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># must be orderable in py3</span>
                        <span class="k">if</span> <span class="n">compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
                            <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="kn">from</span> <span class="nn">.multi</span> <span class="k">import</span> <span class="n">MultiIndex</span>
                        <span class="k">return</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span>
                            <span class="n">data</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">name</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;names&#39;</span><span class="p">))</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                        <span class="c1"># python2 - MultiIndex fails on mixed types</span>
                        <span class="k">pass</span>
            <span class="c1"># other iterable of some kind</span>
            <span class="n">subarr</span> <span class="o">=</span> <span class="n">_asarray_tuplesafe</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">subarr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NOTE for new Index creation:</span>

<span class="sd">    - _simple_new: It returns new Index with the same type as the caller.</span>
<span class="sd">      All metadata (such as name) must be provided by caller&#39;s responsibility.</span>
<span class="sd">      Using _shallow_copy is recommended because it fills these metadata</span>
<span class="sd">      otherwise specified.</span>

<span class="sd">    - _shallow_copy: It returns new Index with the same type (using</span>
<span class="sd">      _simple_new), but fills caller&#39;s metadata otherwise specified. Passed</span>
<span class="sd">      kwargs will overwrite corresponding metadata.</span>

<span class="sd">    - _shallow_copy_with_infer: It returns new Index inferring its type</span>
<span class="sd">      from passed values. It fills caller&#39;s metadata otherwise specified as the</span>
<span class="sd">      same as _shallow_copy.</span>

<span class="sd">    See each method&#39;s docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_simple_new</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        we require the we have a dtype compat for the values</span>
<span class="sd">        if we are passed a non-dtype compat, then coerce using the constructor</span>

<span class="sd">        Must be careful not to recurse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">_reset_identity</span><span class="p">()</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;_shallow_copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        create a new Index with the same class as the caller, don&#39;t copy the</span>
<span class="s2">        data, use the same object attributes with passed in attributes taking</span>
<span class="s2">        precedence</span>

<span class="s2">        *this is an internal non-public method*</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        values : the values to create the new Index, optional</span>
<span class="s2">        kwargs : updates the default attributes for this Index</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;_shallow_copy&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">_shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_shallow_copy_with_infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        create a new Index inferring the class with passed value, don&#39;t copy</span>
<span class="sd">        the data, use the same object attributes with passed in attributes</span>
<span class="sd">        taking precedence</span>

<span class="sd">        *this is an internal non-public method*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : the values to create the new Index, optional</span>
<span class="sd">        kwargs : updates the default attributes for this Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">attributes</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_infer_as_myclass</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deepcopy_if_needed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.19.0</span>

<span class="sd">        Make a copy of self if data coincides (in memory) with orig.</span>
<span class="sd">        Subclasses should override this if self._base is not an ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orig : ndarray</span>
<span class="sd">            other ndarray to compare self._data against</span>
<span class="sd">        copy : boolean, default False</span>
<span class="sd">            when False, do not run any check, just return self</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A copy of self if needed, otherwise self : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># Retrieve the &quot;base objects&quot;, i.e. the original memory allocations</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="n">orig</span> <span class="k">if</span> <span class="n">orig</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">orig</span><span class="o">.</span><span class="n">base</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">base</span>
            <span class="k">if</span> <span class="n">orig</span> <span class="ow">is</span> <span class="n">new</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># guard when called from IndexOpsMixin</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index can&#39;t be updated inplace&quot;</span><span class="p">)</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;_get_grouper_for_level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Get index grouper corresponding to an index level</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        mapper: Group mapping function or None</span>
<span class="s2">            Function mapping index values to groups</span>
<span class="s2">        level : int or None</span>
<span class="s2">            Index level</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        grouper : Index</span>
<span class="s2">            Index of values to group on</span>
<span class="s2">        labels : ndarray of int or None</span>
<span class="s2">            Array of locations in level_index</span>
<span class="s2">        uniques : Index or None</span>
<span class="s2">            Index of unique values for level</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;_get_grouper_for_level&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">_get_grouper_for_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grouper</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grouper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grouper</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">is_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        More flexible, faster check like ``is`` but that works through views</span>

<span class="sd">        Note: this is *not* the same as ``Index.identical()``, which checks</span>
<span class="sd">        that metadata is also the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            other object to compare against.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True if both have same underlying data, False otherwise : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use something other than None to be clearer</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="bp">Ellipsis</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_reset_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes or resets ``_id`` attribute with new object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">_Identity</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># ndarray compat</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the length of the Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; the array interface, return my values &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called after a ufunc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_attributes</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the dtype object of the underlying data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">dtype_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the dtype str of the underlying data &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the underlying data as an ndarray &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the underlying data as an ndarray &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># ops compat</span>
    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return a list of the Index values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeat elements of an Index. Refer to `numpy.ndarray.repeat`</span>
<span class="sd">        for more information about the `n` argument.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.repeat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_repeat</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.19.0</span>

<span class="sd">        Return an Index of same shape as self and whose corresponding</span>
<span class="sd">        entries are from self where cond is True and otherwise are from</span>
<span class="sd">        other.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cond : boolean same length as self</span>
<span class="sd">        other : scalar, or array-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy_with_infer</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return an ndarray of the flattened values of the underlying data</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.ravel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="c1"># construction helpers</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_scalar_data_error</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">(...) must be called with a collection of some &#39;</span>
                        <span class="s1">&#39;kind, </span><span class="si">{1}</span><span class="s1"> was passed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                                      <span class="nb">repr</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_string_data_error</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;String dtype not supported, you may need &#39;</span>
                        <span class="s1">&#39;to explicitly cast to a numeric type&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_coerce_to_ndarray</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;coerces data to ndarray, raises on scalar data. Converts other</span>
<span class="sd">        iterables to list first and then to array. Does not touch ndarrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">_scalar_data_error</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># other iterable of some kind</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_get_attributes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return an attributes dict for my class &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># we need to see if we are subclassing an</span>
        <span class="c1"># index type here</span>
        <span class="k">if</span> <span class="n">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s1">&#39;_typ&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_id</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_coerce_scalar_to_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        we need to coerce a scalar to a compat for our index type</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : scalar item to coerce</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">([</span><span class="n">item</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">())</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Make a copy of this object.  Name and dtype sets those attributes on</span>
<span class="s2">        the new object.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        name : string, optional</span>
<span class="s2">        deep : boolean, default False</span>
<span class="s2">        dtype : numpy dtype or pandas type</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        copy : Index</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        In most cases, there should be no functional difference from using</span>
<span class="s2">        ``deep``, but if ``deep`` is passed it will attempt to deepcopy.</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>

        <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;names&#39;</span><span class="p">)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_names</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_index</span>

    <span class="n">__copy__</span> <span class="o">=</span> <span class="n">copy</span>

    <span class="k">def</span> <span class="nf">_validate_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the quirks of having a singular &#39;name&#39; parameter for general</span>
<span class="sd">        Index and plural &#39;names&#39; parameter for MultiIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only provide one of `names` and `name`&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass list-like as `names`.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for this object.</span>

<span class="sd">        Invoked by unicode(df) in py2 only. Yields a Unicode String in both</span>
<span class="sd">        py2/py3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_data</span><span class="p">()</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_attrs</span><span class="p">()</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_space</span><span class="p">()</span>

        <span class="n">prepr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s2">&quot;,</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span>
                 <span class="n">space</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">u</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">])</span>

        <span class="c1"># no data provided, just attributes</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s%s</span><span class="s2">)&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">prepr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_format_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># using space here controls if the attributes</span>
        <span class="c1"># are line separated or not (the default)</span>

        <span class="c1"># max_seq_items = get_option(&#39;display.max_seq_items&#39;)</span>
        <span class="c1"># if len(self) &gt; max_seq_items:</span>
        <span class="c1">#    space = &quot;\n%s&quot; % (&#39; &#39; * (len(klass) + 1))</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_formatter_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formatted data as a unicode string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">default_pprint</span>

    <span class="k">def</span> <span class="nf">_format_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the formatted data as a unicode string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.formats.format</span> <span class="k">import</span> <span class="n">get_console_size</span><span class="p">,</span> <span class="n">_get_adjustment</span>
        <span class="n">display_width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_console_size</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">display_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">display_width</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;display.width&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">80</span>

        <span class="n">space1</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">space2</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span>
        <span class="n">max_seq_items</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;display.max_seq_items&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter_func</span>

        <span class="c1"># do we want to justify (only do so for non-objects)</span>
        <span class="n">is_justify</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;unicode&#39;</span><span class="p">)</span> <span class="ow">or</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span> <span class="ow">and</span>
                           <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">categories</span><span class="p">)))</span>

        <span class="c1"># are we a truncated display</span>
        <span class="n">is_truncated</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_seq_items</span>

        <span class="c1"># adj can optionaly handle unicode eastern asian width</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">_get_adjustment</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_extend_line</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">display_width</span><span class="p">,</span> <span class="n">next_line_prefix</span><span class="p">):</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span> <span class="o">+</span> <span class="n">adj</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span> <span class="o">&gt;=</span>
                    <span class="n">display_width</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">next_line_prefix</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">line</span>

        <span class="k">def</span> <span class="nf">best_len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">adj</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="s1">&#39;[], &#39;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">], &#39;</span> <span class="o">%</span> <span class="n">first</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">], &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_seq_items</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_seq_items</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
                <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[:</span><span class="n">n</span><span class="p">]]</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="p">[</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="p">[</span><span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

            <span class="c1"># adjust all values to max length if needed</span>
            <span class="k">if</span> <span class="n">is_justify</span><span class="p">:</span>

                <span class="c1"># however, if we are not truncated and we are only a single</span>
                <span class="c1"># line, then don&#39;t justify</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_truncated</span> <span class="ow">or</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">display_width</span> <span class="ow">and</span>
                             <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">display_width</span><span class="p">)):</span>
                    <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best_len</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="n">best_len</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>
                    <span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">head</span><span class="p">]</span>
                    <span class="n">tail</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tail</span><span class="p">]</span>

            <span class="n">summary</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">space2</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">head</span><span class="p">)):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
                <span class="n">summary</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extend_line</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span>
                                             <span class="n">display_width</span><span class="p">,</span> <span class="n">space2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_truncated</span><span class="p">:</span>
                <span class="c1"># remove trailing space of last line</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="n">space2</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">space2</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">tail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
                <span class="n">summary</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extend_line</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span>
                                             <span class="n">display_width</span><span class="p">,</span> <span class="n">space2</span><span class="p">)</span>

            <span class="c1"># last value: no sep added + 1 space of width used for trailing &#39;,&#39;</span>
            <span class="n">summary</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extend_line</span><span class="p">(</span><span class="n">summary</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">tail</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">display_width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">space2</span><span class="p">)</span>
            <span class="n">summary</span> <span class="o">+=</span> <span class="n">line</span>
            <span class="n">summary</span> <span class="o">+=</span> <span class="s1">&#39;],&#39;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">display_width</span><span class="p">):</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="n">space1</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># one row</span>
                <span class="n">summary</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span>

            <span class="c1"># remove initial space</span>
            <span class="n">summary</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="n">summary</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">space2</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">summary</span>

    <span class="k">def</span> <span class="nf">_format_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of tuples of the (attr,formatted_value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">default_pprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
        <span class="n">max_seq_items</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;display.max_seq_items&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_seq_items</span><span class="p">:</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Series with both index and values equal to the index keys</span>
<span class="sd">        useful with map for returning an indexer based on an index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series : dtype will be based on the type of the Index values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_embed</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_embed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_tz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *this is an internal non-public method*</span>

<span class="sd">        return an array repr of this object, potentially casting to object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;astype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Create an Index with values cast to dtypes. The class of a new Index</span>
<span class="s2">        is determined by dtype. When conversion is impossible, a ValueError</span>
<span class="s2">        exception is raised.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        dtype : numpy dtype or pandas type</span>
<span class="s2">        copy : bool, default True</span>
<span class="s2">            By default, astype always returns a newly allocated object.</span>
<span class="s2">            If copy is set to False and internal requirements on dtype are</span>
<span class="s2">            satisfied, the original data is used to create a new Index</span>
<span class="s2">            or the original Index is returned.</span>

<span class="s2">            .. versionadded:: 0.19.0</span>

<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;astype&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_safe_for_reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; convert to object if we are a categorical &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: use :meth:`pandas.to_datetime` instead.</span>

<span class="sd">        For an Index containing strings or datetime.datetime objects, attempt</span>
<span class="sd">        conversion to DatetimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;to_datetime is deprecated. Use pd.to_datetime(...)&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">dateutil.parser</span> <span class="k">import</span> <span class="n">parse</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">parse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">)</span>
            <span class="n">parsed</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">try_parse_dates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">parsed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_can_do_setop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input must be Index or array-like&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_convert_can_do_setop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span>

    <span class="k">def</span> <span class="nf">_convert_for_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert value to be insertable to ndarray &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_assert_can_do_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check value is valid for scalar op &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;value&#39; must be a scalar, passed: </span><span class="si">{0}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nlevels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_get_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FrozenList</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">))</span>

    <span class="k">def</span> <span class="nf">_set_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of new names must be 1, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">names</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fset</span><span class="o">=</span><span class="n">_set_names</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="n">_get_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set new names on index. Defaults to returning new index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : str or sequence</span>
<span class="sd">            name(s) to set</span>
<span class="sd">        level : int, level name, or sequence of int/level names (default None)</span>
<span class="sd">            If the index is a MultiIndex (hierarchical), level(s) to set (None</span>
<span class="sd">            for all levels).  Otherwise level must be None</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            if True, mutates in place</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new index (of same type and class...etc) [if inplace, returns None]</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Index([1, 2, 3, 4]).set_names(&#39;foo&#39;)</span>
<span class="sd">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Index([1, 2, 3, 4]).set_names([&#39;foo&#39;])</span>
<span class="sd">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx = MultiIndex.from_tuples([(1, u&#39;one&#39;), (1, u&#39;two&#39;),</span>
<span class="sd">                                          (2, u&#39;one&#39;), (2, u&#39;two&#39;)],</span>
<span class="sd">                                          names=[&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.set_names([&#39;baz&#39;, &#39;quz&#39;])</span>
<span class="sd">        MultiIndex(levels=[[1, 2], [u&#39;one&#39;, u&#39;two&#39;]],</span>
<span class="sd">                   labels=[[0, 0, 1, 1], [0, 1, 0, 1]],</span>
<span class="sd">                   names=[u&#39;baz&#39;, u&#39;quz&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.set_names(&#39;baz&#39;, level=0)</span>
<span class="sd">        MultiIndex(levels=[[1, 2], [u&#39;one&#39;, u&#39;two&#39;]],</span>
<span class="sd">                   labels=[[0, 0, 1, 1], [0, 1, 0, 1]],</span>
<span class="sd">                   names=[u&#39;baz&#39;, u&#39;bar&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Level must be None for non-MultiIndex&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span>
                <span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Names must be a string&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must pass list-like as `names`.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">_set_names</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set new names on index. Defaults to returning new index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str or list</span>
<span class="sd">            name to set</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            if True, mutates in place</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new index (of same type and class...etc) [if inplace, returns None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_names</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOT IMPLEMENTED: do not call this method, as reshaping is not</span>
<span class="sd">        supported for Index objects and will raise an error.</span>

<span class="sd">        Reshape an Index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;reshaping is not supported &quot;</span>
                                  <span class="s2">&quot;for Index objects&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_has_complex_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># to disable groupby tricks in MultiIndex</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="s1">&#39;format&#39;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="s1">&#39;format&#39;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
            <span class="n">index_summary</span> <span class="o">=</span> <span class="s1">&#39;, </span><span class="si">%s</span><span class="s1"> to </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">head</span><span class="p">),</span>
                                            <span class="n">pprint_thing</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_summary</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1"> entries</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">index_summary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mpl_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># how to represent ourselves to matplotlib</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="n">_na_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="sd">&quot;&quot;&quot;The expected NA value to use with this index.&quot;&quot;&quot;</span>

    <span class="c1"># introspection</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; alias for is_monotonic_increasing (deprecated) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_monotonic_increasing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return if the index is monotonic increasing (only equal or</span>
<span class="sd">        increasing) values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_monotonic_decreasing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return if the index is monotonic decreasing (only equal or</span>
<span class="sd">        decreasing) values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span>

    <span class="k">def</span> <span class="nf">is_lexsorted_for_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tup</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@cache_readonly</span><span class="p">(</span><span class="n">allow_setting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return if the index has unique values &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">is_unique</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span>

    <span class="k">def</span> <span class="nf">is_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;boolean&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;integer&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_floating</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;floating&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed-integer-float&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="s1">&#39;floating&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;categorical&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_mixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mixed&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">holds_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="s1">&#39;mixed-integer&#39;</span><span class="p">]</span>

    <span class="c1"># validate / convert indexers</span>
    <span class="k">def</span> <span class="nf">_convert_scalar_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        convert a scalar indexer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label of the slice bound</span>
<span class="sd">        kind : {&#39;ix&#39;, &#39;loc&#39;, &#39;getitem&#39;, &#39;iloc&#39;} or None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;iloc&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;positional&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">,):</span>

            <span class="c1"># we can raise here if we are definitive that this</span>
            <span class="c1"># is positional indexing (eg. .ix on with a float)</span>
            <span class="c1"># or label indexing if we are using a type able</span>
            <span class="c1"># to be represented in the index</span>

            <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;ix&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_float</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_floating</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_float</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>

                <span class="c1"># we want to raise KeyError on string/mixed here</span>
                <span class="c1"># technically we *could* raise a TypeError</span>
                <span class="c1"># on anything but mixed though</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;floating&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mixed-integer-float&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;string&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;unicode&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;mixed&#39;</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">holds_integer</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">_convert_slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        convert a slice indexer. disallow floats in the start/stop/step</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label of the slice bound</span>
<span class="sd">        kind : {&#39;ix&#39;, &#39;loc&#39;, &#39;getitem&#39;, &#39;iloc&#39;} or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># if we are not a slice, then we are done</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span>

        <span class="c1"># validate iloc</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;iloc&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">kind</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">kind</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">kind</span><span class="p">))</span>

        <span class="c1"># potentially cast the bounds to integers</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>

        <span class="c1"># figure out if this is a positional indexer</span>
        <span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="n">is_null_slicer</span> <span class="o">=</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">is_index_slice</span> <span class="o">=</span> <span class="n">is_int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_int</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">is_positional</span> <span class="o">=</span> <span class="n">is_index_slice</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;getitem&#39;</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            called from the getitem slicers, validate that we are in fact</span>
<span class="sd">            integers</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">or</span> <span class="n">is_index_slice</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">kind</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">kind</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">kind</span><span class="p">))</span>

        <span class="c1"># convert the slice to an indexer here</span>

        <span class="c1"># if we are mixed and have integers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_positional</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mixed</span><span class="p">():</span>
                <span class="c1"># TODO: i, j are not used anywhere</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>  <span class="c1"># noqa</span>
                <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>  <span class="c1"># noqa</span>
                <span class="n">is_positional</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;mixed-integer-float&#39;</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="k">if</span> <span class="n">is_null_slicer</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="n">is_positional</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_indexer</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_index_slice</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
                        <span class="k">raise</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">return</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_convert_list_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyarr</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        passed a key that is tuplesafe that is integer based</span>
<span class="sd">        and we have a mixed index (e.g. number/labels). figure out</span>
<span class="sd">        the indexer. return None if we can&#39;t help</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">,</span> <span class="s1">&#39;ix&#39;</span><span class="p">]</span> <span class="ow">and</span>
                <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">keyarr</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_floating</span><span class="p">()</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keyarr</span><span class="p">,</span> <span class="n">ABCPeriodIndex</span><span class="p">)):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;mixed-integer&#39;</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">keyarr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">indexer</span>
                <span class="c1"># missing values are flagged as -1 by get_indexer and negative</span>
                <span class="c1"># indices are already converted to positive indices in the</span>
                <span class="c1"># above if-statement, so the negative flags are changed to</span>
                <span class="c1"># values outside the range of indices so as to trigger an</span>
                <span class="c1"># IndexError in maybe_convert_indices</span>
                <span class="n">indexer</span><span class="p">[</span><span class="n">indexer</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="k">import</span> <span class="n">maybe_convert_indices</span>
                <span class="k">return</span> <span class="n">maybe_convert_indices</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
                <span class="n">keyarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">keyarr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">keyarr</span><span class="p">,</span> <span class="n">keyarr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">keyarr</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_invalid_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; consistent invalid indexer message &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot do </span><span class="si">{form}</span><span class="s2"> indexing on </span><span class="si">{klass}</span><span class="s2"> with these &quot;</span>
                        <span class="s2">&quot;indexers [</span><span class="si">{key}</span><span class="s2">] of </span><span class="si">{kind}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">form</span><span class="o">=</span><span class="n">form</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                            <span class="n">kind</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">get_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="n">counter</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">_get_duplicates</span> <span class="o">=</span> <span class="n">get_duplicates</span>

    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">clear_mapping</span><span class="p">()</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_engine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># property, for now, slow to look up</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine_type</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_validate_index_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate index level.</span>

<span class="sd">        For single-level Index getting level number is a no-op, but some</span>
<span class="sd">        verification must be done like in MultiIndex.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Too many levels: Index has only 1 level,&quot;</span>
                                 <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> is not a valid level number&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">))</span>
            <span class="k">elif</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Too many levels:&quot;</span>
                                 <span class="s2">&quot; Index has only 1 level, not </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">level</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Level </span><span class="si">%s</span><span class="s1"> must be same as name (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_level_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">inferred_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return a string of the type inferred from the values &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_type_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kind</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">is_all_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">is_datetime_array</span><span class="p">(</span><span class="n">_ensure_object</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">_new_Index</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Necessary for making this object picklable&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">nd_state</span><span class="p">,</span> <span class="n">own_state</span> <span class="o">=</span> <span class="n">state</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nd_state</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nd_state</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nd_state</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">own_state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_identity</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;invalid pickle state&quot;</span><span class="p">)</span>

    <span class="n">_unpickle_compat</span> <span class="o">=</span> <span class="n">__setstate__</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truth value of a </span><span class="si">{0}</span><span class="s2"> is ambiguous. &quot;</span>
                         <span class="s2">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

    <span class="n">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="nb">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># work around some kind of odd cython bug</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unhashable type: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index does not support mutable operations&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override numpy.ndarray&#39;s __getitem__ method to work as desired.</span>

<span class="sd">        This function adds lists and Series as valid boolean indexers</span>
<span class="sd">        (ndarrays only supports ndarray with dtype=bool).</span>

<span class="sd">        If resulting ndim != 1, plain ndarray is returned instead of</span>
<span class="sd">        corresponding `Index` subclass.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There&#39;s no custom logic to be implemented in __getslice__, so it&#39;s</span>
        <span class="c1"># not overloaded intentionally.</span>
        <span class="n">getitem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__getitem__</span>
        <span class="n">promote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># This case is separated from the conditional above to avoid</span>
            <span class="c1"># pessimization of basic indexing.</span>
            <span class="k">return</span> <span class="n">promote</span><span class="p">(</span><span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">promote</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a collection of Index options together</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or list/tuple of indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        appended : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="n">to_concat</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;all inputs must be Index&#39;</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">])</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical</span><span class="p">():</span>
            <span class="c1"># if calling index is category, don&#39;t check dtype of others</span>
            <span class="kn">from</span> <span class="nn">pandas.indexes.category</span> <span class="k">import</span> <span class="n">CategoricalIndex</span>
            <span class="k">return</span> <span class="n">CategoricalIndex</span><span class="o">.</span><span class="n">_append_same_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_concat</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="n">typs</span> <span class="o">=</span> <span class="n">_concat</span><span class="o">.</span><span class="n">get_dtype_kinds</span><span class="p">(</span><span class="n">to_concat</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">typs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_same_dtype</span><span class="p">(</span><span class="n">to_concat</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_concat</span><span class="o">.</span><span class="n">_concat_index_asobject</span><span class="p">(</span><span class="n">to_concat</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_append_same_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_concat</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate to_concat which has the same class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># must be overrided in specific classes</span>
        <span class="k">return</span> <span class="n">_concat</span><span class="o">.</span><span class="n">_concat_index_asobject</span><span class="p">(</span><span class="n">to_concat</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;take&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        return a new </span><span class="si">%(klass)s</span><span class="s2"> of the values selected by the indices</span>

<span class="s2">        For internal compatibility with numpy arrays.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        indices : list</span>
<span class="s2">            Indices to be taken</span>
<span class="s2">        axis : int, optional</span>
<span class="s2">            The axis over which to select values, always 0.</span>
<span class="s2">        allow_fill : bool, default True</span>
<span class="s2">        fill_value : bool, default None</span>
<span class="s2">            If allow_fill=True and fill_value is not None, indices specified by</span>
<span class="s2">            -1 is regarded as NA. If Index doesn&#39;t hold NA, raise ValueError</span>

<span class="s2">        See also</span>
<span class="s2">        --------</span>
<span class="s2">        numpy.ndarray.take</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;take&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_take</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_take_fillable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span>
                                               <span class="n">allow_fill</span><span class="o">=</span><span class="n">allow_fill</span><span class="p">,</span>
                                               <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                               <span class="n">na_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_na_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_fill</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Unable to fill values because </span><span class="si">{0}</span><span class="s1"> cannot contain NA&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">taken</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assert_take_fillable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal method to handle NA filling of take &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># only fill if we are passing a non-None fill_value</span>
        <span class="k">if</span> <span class="n">allow_fill</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;When allow_fill=True and fill_value is not None, &#39;</span>
                       <span class="s1">&#39;all indices must be &gt;= -1&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">taken</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">taken</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return if each value is nan&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># shouldn&#39;t reach to this condition by checking hasnans beforehand</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">values</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_nan_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="n">w</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hasnans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return if I have any nans; enables various perf speedups &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_hold_na</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">putmask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return a new Index of the values set with the mask</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.putmask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_for_op</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="c1"># coerces to object</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a string representation of the Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                       <span class="n">escape_chars</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span> <span class="k">if</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">formatter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">header</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">formatter</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_with_header</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_with_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;NaN&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

        <span class="kn">from</span> <span class="nn">pandas.formats.format</span> <span class="k">import</span> <span class="n">format_array</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">safe</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">escape_chars</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

            <span class="c1"># could have nans</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_rep</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_trim_front</span><span class="p">(</span><span class="n">format_array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">justify</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">header</span> <span class="o">+</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_native_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; slice and dice then format &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">slicer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">_format_native_types</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_native_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">quoting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; actually format my specific types &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_object</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quoting</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_rep</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if two Index objects contain the same elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># if other is not object, use other&#39;s logic for coercion</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">array_equivalent</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                    <span class="n">_values_from_object</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">identical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Similar to equals, but check that other comparable attributes are</span>
<span class="sd">        also equal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">all</span><span class="p">((</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparables</span><span class="p">))</span> <span class="ow">and</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a sorted index, return the most recent label up to and including</span>
<span class="sd">        the passed label. Return NaN if not found.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        get_loc : asof is a thin wrapper around get_loc with method=&#39;pad&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_na_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">asof_locs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        where : array of timestamps</span>
<span class="sd">        mask : array of booleans where data is not NA</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">where</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">locs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>

        <span class="n">first</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[(</span><span class="n">locs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">where</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">first</span><span class="p">])]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_indexer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sorted copy of Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_as</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">_as</span> <span class="o">=</span> <span class="n">_as</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">sorted_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">_as</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_indexer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sorted_index</span><span class="p">,</span> <span class="n">_as</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sorted_index</span>

    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_indexer</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return sorted copy of Index</span>

<span class="sd">        DEPRECATED: use :meth:`Index.sort_values`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;order is deprecated, use sort_values(...)&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">return_indexer</span><span class="o">=</span><span class="n">return_indexer</span><span class="p">,</span>
                                <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot sort an Index object in-place, use &quot;</span>
                        <span class="s2">&quot;sort_values instead&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        For internal compatibility with with the Index API</span>

<span class="sd">        Sort the Index. This is for compat with MultiIndex</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ascending : boolean, default True</span>
<span class="sd">            False to sort in descending order</span>

<span class="sd">        level, sort_remaining are compat parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_index : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">return_indexer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift Index containing datetime objects by input number of periods and</span>
<span class="sd">        DateOffset</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not supported for type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                  <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices that would sort the index and its</span>
<span class="sd">        underlying data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        argsorted : numpy array</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.argsort</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asi8</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="n">__iadd__</span> <span class="o">=</span> <span class="n">__add__</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot perform __sub__ with this index type: &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_consensus_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given 2 indexes, give a consensus name meaning</span>
<span class="sd">        we take the not None one, or None if the names differ.</span>
<span class="sd">        Return a new object if we are resetting the name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form the union of two Index objects and sorts if possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        union : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.union(idx2)</span>
<span class="sd">        Int64Index([1, 2, 3, 4, 5, 6], dtype=&#39;int64&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_consensus_name</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_consensus_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outer_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># incomparable objects</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

                <span class="c1"># worth making this faster? a very unusual case</span>
                <span class="n">value_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">value_set</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">indexer</span><span class="p">,</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">other_diff</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">take_nd</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span>
                                           <span class="n">allow_fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_concat</span><span class="o">.</span><span class="n">_concat_compat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other_diff</span><span class="p">))</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">other_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, sort order is undefined for &quot;</span>
                                  <span class="s2">&quot;incomparable objects&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">,</span>
                                  <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">types</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span><span class="p">,</span>
                                       <span class="n">other</span><span class="o">.</span><span class="n">inferred_type</span><span class="p">))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">types</span> <span class="o">&amp;</span> <span class="n">_unsortable_types</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, sort order is undefined for &quot;</span>
                                  <span class="s2">&quot;incomparable objects&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">,</span>
                                  <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># for subclasses</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_union_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_wrap_union_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form the intersection of two Index objects.</span>

<span class="sd">        This returns a new Index with elements common to the index and `other`.</span>
<span class="sd">        Sortedness of the result is not guaranteed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intersection : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.intersection(idx2)</span>
<span class="sd">        Int64Index([3, 4], dtype=&#39;int64&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_consensus_name</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_union_result</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">take</span><span class="p">((</span><span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># duplicates</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="p">[</span><span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">taken</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">taken</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">taken</span>

    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Index with elements from the index that are not in</span>
<span class="sd">        `other`.</span>

<span class="sd">        This is the set difference of two Index objects.</span>
<span class="sd">        It&#39;s sorted if sorting is possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        difference : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.difference(idx2)</span>
<span class="sd">        Int64Index([1, 2], dtype=&#39;int64&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unique_index</span><span class="p">()</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">take</span><span class="p">((</span><span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">label_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">indexer</span><span class="p">,</span>
                                  <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">the_diff</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">label_diff</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">the_diff</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">safe_sort</span><span class="p">(</span><span class="n">the_diff</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">the_diff</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">result_name</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">result_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symmetric difference of two Index objects.</span>
<span class="sd">        It&#39;s sorted if sorting is possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        result_name : str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        symmetric_difference : Index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``symmetric_difference`` contains elements that appear in either</span>
<span class="sd">        ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by</span>
<span class="sd">        ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates</span>
<span class="sd">        dropped.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx1 = Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = Index([2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; idx1.symmetric_difference(idx2)</span>
<span class="sd">        Int64Index([1, 5], dtype=&#39;int64&#39;)</span>

<span class="sd">        You can also use the ``^`` operator:</span>

<span class="sd">        &gt;&gt;&gt; idx1 ^ idx2</span>
<span class="sd">        Int64Index([1, 5], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other</span><span class="p">,</span> <span class="n">result_name_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_can_do_setop</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result_name</span> <span class="o">=</span> <span class="n">result_name_update</span>

        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unique_index</span><span class="p">()</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_unique_index</span><span class="p">()</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># {this} minus {other}</span>
        <span class="n">common_indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">take</span><span class="p">((</span><span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">common_indexer</span><span class="p">,</span>
                                    <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">left_diff</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">left_indexer</span><span class="p">)</span>

        <span class="c1"># {other} minus {this}</span>
        <span class="n">right_indexer</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">right_diff</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">right_indexer</span><span class="p">)</span>

        <span class="n">the_diff</span> <span class="o">=</span> <span class="n">_concat</span><span class="o">.</span><span class="n">_concat_compat</span><span class="p">([</span><span class="n">left_diff</span><span class="p">,</span> <span class="n">right_diff</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">the_diff</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">safe_sort</span><span class="p">(</span><span class="n">the_diff</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">attribs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
        <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_name</span>
        <span class="k">if</span> <span class="s1">&#39;freq&#39;</span> <span class="ow">in</span> <span class="n">attribs</span><span class="p">:</span>
            <span class="n">attribs</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy_with_infer</span><span class="p">(</span><span class="n">the_diff</span><span class="p">,</span> <span class="o">**</span><span class="n">attribs</span><span class="p">)</span>

    <span class="n">sym_diff</span> <span class="o">=</span> <span class="n">deprecate</span><span class="p">(</span><span class="s1">&#39;sym_diff&#39;</span><span class="p">,</span> <span class="n">symmetric_difference</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_unique_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an index containing unique values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dropna : bool</span>
<span class="sd">            If True, NaN values are dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        uniques : index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dropna</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">dropna</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">isnull</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integer location for requested label</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : label</span>
<span class="sd">        method : {None, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;, &#39;nearest&#39;}, optional</span>
<span class="sd">            * default: exact matches only.</span>
<span class="sd">            * pad / ffill: find the PREVIOUS index value if no exact match.</span>
<span class="sd">            * backfill / bfill: use NEXT index value if no exact match</span>
<span class="sd">            * nearest: use the NEAREST index value if no exact match. Tied</span>
<span class="sd">              distances are broken by preferring the larger index value.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance from index value for inexact matches. The value of</span>
<span class="sd">            the index at the matching location most satisfy the equation</span>
<span class="sd">            ``abs(index[loc] - key) &lt;= tolerance``.</span>

<span class="sd">            .. versionadded:: 0.17.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loc : int if unique index, possibly slice or mask if not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tolerance argument only valid if using pad, &#39;</span>
                                 <span class="s1">&#39;backfill or nearest lookups&#39;</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">([</span><span class="n">key</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexer</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">indexer</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;get_loc requires scalar valued input&#39;</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast lookup of value from 1-dimensional ndarray. Only use this if you</span>
<span class="sd">        know what you&#39;re doing</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if we have something that is Index-like, then</span>
        <span class="c1"># use this, e.g. DatetimeIndex</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="s1">&#39;_values&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>

                <span class="c1"># invalid type as an indexer</span>
                <span class="k">pass</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_scalar_indexer</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;getitem&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
                                          <span class="n">tz</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;tz&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="s1">&#39;boolean&#39;</span><span class="p">]:</span>
                <span class="k">raise</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tslib</span><span class="o">.</span><span class="n">get_value_box</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># generator/iterator-like</span>
                <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e1</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="n">e1</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># python 3</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast lookup of value from 1-dimensional ndarray. Only use this if you</span>
<span class="sd">        know what you&#39;re doing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span>
                               <span class="n">_values_from_object</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return vector of label values for requested level, equal to the length</span>
<span class="sd">        of the index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># checks that level number is actually just 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute indexer and mask for new index given the current index. The</span>
<span class="sd">        indexer should be then used as an input to ndarray.take to align the</span>
<span class="sd">        current data to the new index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : Index</span>
<span class="sd">        method : {None, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;, &#39;nearest&#39;}, optional</span>
<span class="sd">            * default: exact matches only.</span>
<span class="sd">            * pad / ffill: find the PREVIOUS index value if no exact match.</span>
<span class="sd">            * backfill / bfill: use NEXT index value if no exact match</span>
<span class="sd">            * nearest: use the NEAREST index value if no exact match. Tied</span>
<span class="sd">              distances are broken by preferring the larger index value.</span>
<span class="sd">        limit : int, optional</span>
<span class="sd">            Maximum number of consecutive labels in ``target`` to match for</span>
<span class="sd">            inexact matches.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between original and new labels for inexact</span>
<span class="sd">            matches. The values of the index at the matching locations most</span>
<span class="sd">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="sd">            .. versionadded:: 0.17.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indexer = index.get_indexer(new_index)</span>
<span class="sd">        &gt;&gt;&gt; new_values = cur_values.take(indexer)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indexer : ndarray of int</span>
<span class="sd">            Integers from 0 to n - 1 indicating that the index at these</span>
<span class="sd">            positions matches the corresponding target values. Missing values</span>
<span class="sd">            in the target are marked by -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_reindex_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_tolerance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="n">pself</span><span class="p">,</span> <span class="n">ptarget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_possibly_promote</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">or</span> <span class="n">ptarget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pself</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">ptarget</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                     <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                    <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span><span class="s1">&#39;Reindexing only valid with uniquely&#39;</span>
                                    <span class="s1">&#39; valued Index objects&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pad&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;backfill&#39;</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fill_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nearest_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tolerance argument only valid if doing pad, &#39;</span>
                                 <span class="s1">&#39;backfill or nearest reindexing&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;limit argument only valid if doing pad, &#39;</span>
                                 <span class="s1">&#39;backfill or nearest reindexing&#39;</span><span class="p">)</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert_tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="c1"># override this method on subclasses</span>
        <span class="k">return</span> <span class="n">tolerance</span>

    <span class="k">def</span> <span class="nf">_get_fill_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_pad_indexer</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pad&#39;</span> <span class="k">else</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_backfill_indexer</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fill_indexer_searchsorted</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                                          <span class="n">limit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_indexer_tolerance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span>
                                                     <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_get_fill_indexer_searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fallback pad/backfill get_indexer that works for monotonic decreasing</span>
<span class="sd">        indexes and non-monotonic targets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;limit argument for </span><span class="si">%r</span><span class="s1"> method only well-defined &#39;</span>
                             <span class="s1">&#39;if index and target are monotonic&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pad&#39;</span> <span class="k">else</span> <span class="s1">&#39;right&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># find exact matches first (this simplifies the algorithm)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">nonexact</span> <span class="o">=</span> <span class="p">(</span><span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">nonexact</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searchsorted_monotonic</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">nonexact</span><span class="p">],</span>
                                                         <span class="n">side</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="c1"># searchsorted returns &quot;indices into a sorted array such that,</span>
            <span class="c1"># if the corresponding elements in v were inserted before the</span>
            <span class="c1"># indices, the order of a would be preserved&quot;.</span>
            <span class="c1"># Thus, we need to subtract 1 to find values to the left.</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">nonexact</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># This also mapped not found values (values of 0 from</span>
            <span class="c1"># np.searchsorted) to -1, which conveniently is also our</span>
            <span class="c1"># sentinel for missing values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Mark indices to the right of the largest value as not found</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">indexer</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_get_nearest_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the indexer for the nearest index labels; requires an index with</span>
<span class="sd">        values that can be subtracted from each other (e.g., not strings or</span>
<span class="sd">        tuples).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="n">right_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;backfill&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">left_distances</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">right_distances</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">right_indexer</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">left_distances</span><span class="p">,</span> <span class="n">right_distances</span><span class="p">)</span> <span class="o">|</span>
                           <span class="p">(</span><span class="n">right_indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">left_indexer</span><span class="p">,</span> <span class="n">right_indexer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_indexer_tolerance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span>
                                                     <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_filter_indexer_tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">get_indexer_non_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return an indexer suitable for taking from a non unique index</span>
<span class="sd">            return the labels in the same order as the target, and</span>
<span class="sd">            return a missing indexer into the target (missing are marked as -1</span>
<span class="sd">            in the indexer); target must be an iterable &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">pself</span><span class="p">,</span> <span class="n">ptarget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_possibly_promote</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pself</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">or</span> <span class="n">ptarget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pself</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">ptarget</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_all_dates</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asi8</span><span class="p">)</span>
            <span class="n">tgt_values</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">asi8</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tgt_values</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">_values</span>

        <span class="n">indexer</span><span class="p">,</span> <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_engine</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">tgt_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">indexer</span><span class="p">),</span> <span class="n">missing</span>

    <span class="k">def</span> <span class="nf">get_indexer_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; guaranteed return of an indexer even when non-unique &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">indexer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_possibly_promote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># A hack, but it works</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.index</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;date&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DatetimeIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;boolean&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group the index labels by a given array of values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : array</span>
<span class="sd">            Values used to determine the groups.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        groups : dict</span>
<span class="sd">            {group name -&gt; group labels}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: if we are a MultiIndex, we can do better</span>
        <span class="c1"># that converting to tuples</span>
        <span class="kn">from</span> <span class="nn">.multi</span> <span class="k">import</span> <span class="n">MultiIndex</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_ensure_categorical</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_reverse_indexer</span><span class="p">()</span>

        <span class="c1"># map to the label</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">result</span><span class="p">)}</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply mapper function to its values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : callable</span>
<span class="sd">            Function to be applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        applied : array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mapper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute boolean array of whether each index value is found in the</span>
<span class="sd">        passed set of values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : set or list-like</span>
<span class="sd">            Sought values.</span>

<span class="sd">            .. versionadded:: 0.18.1</span>

<span class="sd">            Support for values as a set</span>

<span class="sd">        level : str or int, optional</span>
<span class="sd">            Name or position of the index level to use (if the index is a</span>
<span class="sd">            MultiIndex).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `level` is specified:</span>

<span class="sd">        - if it is the name of one *and only one* index level, use that level;</span>
<span class="sd">        - otherwise it should be a number indicating level position.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_contained : ndarray (boolean dtype)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">algos</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_can_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *this is an internal non-public method*</span>

<span class="sd">        Check if we are allowing reindexing with this particular indexer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indexer : an integer indexer</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if its a duplicate axis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># trying to reindex on an axis with duplicates</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot reindex from a duplicate axis&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create index with target&#39;s values (move/add/delete values as necessary)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : an iterable</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : pd.Index</span>
<span class="sd">            Resulting index</span>
<span class="sd">        indexer : np.ndarray or None</span>
<span class="sd">            Indices of output values in original index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GH6552: preserve names when reindexing to non-named target</span>
        <span class="c1"># (i.e. neither Index nor Series).</span>
        <span class="n">preserve_names</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>

        <span class="c1"># GH7774: preserve dtype/tz if target is empty and not an Index.</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_ensure_has_len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>  <span class="c1"># target may be an iterator</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># don&#39;t preserve freq</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Fill method not supported if level passed&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_level</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span>
                                             <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                    <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                               <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                               <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot reindex a non-unique index &quot;</span>
                                         <span class="s2">&quot;with a method or limit&quot;</span><span class="p">)</span>
                    <span class="n">indexer</span><span class="p">,</span> <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">preserve_names</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">target</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="n">target</span><span class="p">,</span> <span class="n">indexer</span>

    <span class="k">def</span> <span class="nf">_reindex_non_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *this is an internal non-public method*</span>

<span class="sd">        Create a new index with target&#39;s values (move/add/delete values as</span>
<span class="sd">        necessary) use with non-unique Index and a possibly non-unique target</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : an iterable</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : pd.Index</span>
<span class="sd">            Resulting index</span>
<span class="sd">        indexer : np.ndarray or None</span>
<span class="sd">            Indices of output values in original index</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">indexer</span><span class="p">,</span> <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">check</span><span class="p">])</span>
        <span class="n">new_indexer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">))</span>

            <span class="n">missing</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
            <span class="n">missing_labels</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span>
            <span class="n">missing_indexer</span> <span class="o">=</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">])</span>
            <span class="n">cur_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">check</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
            <span class="n">cur_indexer</span> <span class="o">=</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">check</span><span class="p">])</span>

            <span class="n">new_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">)]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">new_labels</span><span class="p">[</span><span class="n">cur_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_labels</span>
            <span class="n">new_labels</span><span class="p">[</span><span class="n">missing_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_labels</span>

            <span class="c1"># a unique indexer</span>
            <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>

                <span class="c1"># see GH5553, make sure we use the right indexer</span>
                <span class="n">new_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">))</span>
                <span class="n">new_indexer</span><span class="p">[</span><span class="n">cur_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cur_labels</span><span class="p">))</span>
                <span class="n">new_indexer</span><span class="p">[</span><span class="n">missing_indexer</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># we have a non_unique selector, need to use the original</span>
            <span class="c1"># indexer here</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># need to retake to have the same size as the indexer</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="o">.</span><span class="n">values</span>
                <span class="n">indexer</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># reset the new indexer to account for the new size</span>
                <span class="n">new_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">)))</span>
                <span class="n">new_indexer</span><span class="p">[</span><span class="o">~</span><span class="n">check</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy_with_infer</span><span class="p">(</span><span class="n">new_labels</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">new_indexer</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *this is an internal non-public method*</span>

<span class="sd">        Compute join_index and indexers to conform data</span>
<span class="sd">        structures to the new index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index</span>
<span class="sd">        how : {&#39;left&#39;, &#39;right&#39;, &#39;inner&#39;, &#39;outer&#39;}</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">        return_indexers : boolean, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        join_index, (left_indexer, right_indexer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.multi</span> <span class="k">import</span> <span class="n">MultiIndex</span>
        <span class="n">self_is_mi</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
        <span class="n">other_is_mi</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>

        <span class="c1"># try to figure out the join level</span>
        <span class="c1"># GH3662</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">self_is_mi</span> <span class="ow">or</span> <span class="n">other_is_mi</span><span class="p">):</span>

            <span class="c1"># have the same levels/names so a simple join</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_multi</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                        <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>

        <span class="c1"># join on the level</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">self_is_mi</span> <span class="ow">or</span> <span class="n">other_is_mi</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_level</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                    <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">):</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
                <span class="n">rindexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">join_index</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rindexer</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">join_index</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">how</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">):</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
                <span class="n">lindexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">join_index</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lindexer</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">join_index</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_precedence</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_join_precedence</span><span class="p">:</span>
            <span class="n">how</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;right&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>

        <span class="n">_validate_join_method</span><span class="p">(</span><span class="n">how</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_non_unique</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                         <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_monotonic</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                            <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_non_unique</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                             <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_monotonic</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                            <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">lindexer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lindexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
                <span class="n">rindexer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rindexer</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lindexer</span><span class="p">,</span> <span class="n">rindexer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">join_index</span>

    <span class="k">def</span> <span class="nf">_join_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.multi</span> <span class="k">import</span> <span class="n">MultiIndex</span>
        <span class="n">self_is_mi</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
        <span class="n">other_is_mi</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>

        <span class="c1"># figure out join names</span>
        <span class="n">self_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">other_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">self_names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">other_names</span><span class="p">))</span>

        <span class="c1"># need at least 1 in common, but not more than 1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot join with no level specified and no &quot;</span>
                             <span class="s2">&quot;overlapping names&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;merging with more than one level &quot;</span>
                                      <span class="s2">&quot;overlap on a multi-index is not &quot;</span>
                                      <span class="s2">&quot;implemented&quot;</span><span class="p">)</span>
        <span class="n">jl</span> <span class="o">=</span> <span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># make the indices into mi&#39;s that match</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">self_is_mi</span> <span class="ow">and</span> <span class="n">other_is_mi</span><span class="p">):</span>

            <span class="n">flip_order</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">self_is_mi</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span>
                <span class="n">flip_order</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># flip if join method is right or left</span>
                <span class="n">how</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;right&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>

            <span class="n">level</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">jl</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_level</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                      <span class="n">return_indexers</span><span class="o">=</span><span class="n">return_indexers</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># 2 multi-indexes</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;merging with both multi-indexes is not &quot;</span>
                                  <span class="s2">&quot;implemented&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_join_non_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.tools.merge</span> <span class="k">import</span> <span class="n">_get_join_indexers</span>

        <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span> <span class="o">=</span> <span class="n">_get_join_indexers</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">],</span>
                                                 <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                                 <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">left_idx</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span>
        <span class="n">right_idx</span> <span class="o">=</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">right_idx</span><span class="p">)</span>

        <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">left_idx</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">left_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">right_idx</span><span class="p">))</span>

        <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">join_index</span>

    <span class="k">def</span> <span class="nf">_join_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">keep_order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The join method *only* affects the level of the resulting</span>
<span class="sd">        MultiIndex. Otherwise it just exactly aligns the Index data to the</span>
<span class="sd">        labels of the level in the MultiIndex. If `keep_order` == True, the</span>
<span class="sd">        order of the data indexed by the MultiIndex will not be changed;</span>
<span class="sd">        otherwise, it will tie out with `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.algos</span> <span class="k">import</span> <span class="n">groupsort_indexer</span>
        <span class="kn">from</span> <span class="nn">.multi</span> <span class="k">import</span> <span class="n">MultiIndex</span>

        <span class="k">def</span> <span class="nf">_get_leaf_sorter</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            returns sorter for the inner most level while preserving the</span>
<span class="sd">            order of higher levels</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lab</span> <span class="o">=</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">sorter</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">groupsort_indexer</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">lab</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">sorter</span>

            <span class="c1"># find indexers of begining of each set of</span>
            <span class="c1"># same-key labels w.r.t all but last level</span>
            <span class="n">tic</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">tic</span> <span class="o">|=</span> <span class="n">lab</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lab</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(([</span><span class="kc">True</span><span class="p">],</span> <span class="n">tic</span><span class="p">,</span> <span class="p">[</span><span class="kc">True</span><span class="p">]))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lab</span> <span class="o">=</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">get_level_sorter</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">starts</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Join on level between two MultiIndex objects &#39;</span>
                            <span class="s1">&#39;is ambiguous&#39;</span><span class="p">)</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span>

        <span class="n">flip_order</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">,</span> <span class="n">left</span>
            <span class="n">how</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;right&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>

        <span class="n">level</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">old_level</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Index._join_level on non-unique index &#39;</span>
                                      <span class="s1">&#39;is not implemented&#39;</span><span class="p">)</span>

        <span class="n">new_level</span><span class="p">,</span> <span class="n">left_lev_indexer</span><span class="p">,</span> <span class="n">right_lev_indexer</span> <span class="o">=</span> \
            <span class="n">old_level</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">left_lev_indexer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">keep_order</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># sort the leaves</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">_get_leaf_sorter</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">labels</span><span class="p">[:</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_lev_indexer</span> <span class="o">=</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">left_lev_indexer</span><span class="p">)</span>
            <span class="n">rev_indexer</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">get_reverse_indexer</span><span class="p">(</span><span class="n">left_lev_indexer</span><span class="p">,</span>
                                                  <span class="nb">len</span><span class="p">(</span><span class="n">old_level</span><span class="p">))</span>

            <span class="n">new_lev_labels</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">take_nd</span><span class="p">(</span><span class="n">rev_indexer</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
                                           <span class="n">allow_fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">new_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">new_labels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lev_labels</span>

            <span class="n">new_levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="n">new_levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_level</span>

            <span class="k">if</span> <span class="n">keep_order</span><span class="p">:</span>  <span class="c1"># just drop missing values. o.w. keep order</span>
                <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">new_lev_labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">new_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_labels</span><span class="p">]</span>
                    <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">left_indexer</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># tie out the order with other</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># outer most level, take the fast route</span>
                    <span class="n">ngroups</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">new_lev_labels</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">left_indexer</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">groupsort_indexer</span><span class="p">(</span><span class="n">new_lev_labels</span><span class="p">,</span>
                                                             <span class="n">ngroups</span><span class="p">)</span>
                    <span class="c1"># missing values are placed first; drop them!</span>
                    <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">left_indexer</span><span class="p">[</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>
                    <span class="n">new_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_labels</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># sort the leaves</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">new_lev_labels</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">mask_all</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mask_all</span><span class="p">:</span>
                        <span class="n">new_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_labels</span><span class="p">]</span>

                    <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">_get_leaf_sorter</span><span class="p">(</span><span class="n">new_labels</span><span class="p">[:</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">new_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab</span><span class="p">[</span><span class="n">left_indexer</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">new_labels</span><span class="p">]</span>

                    <span class="c1"># left_indexers are w.r.t masked frame.</span>
                    <span class="c1"># reverse to original frame!</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">mask_all</span><span class="p">:</span>
                        <span class="n">left_indexer</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="n">left_indexer</span><span class="p">]</span>

            <span class="n">join_index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="n">new_levels</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">new_labels</span><span class="p">,</span>
                                    <span class="n">names</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">right_lev_indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">right_indexer</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">take_nd</span><span class="p">(</span><span class="n">right_lev_indexer</span><span class="p">,</span>
                                          <span class="n">join_index</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
                                          <span class="n">allow_fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right_indexer</span> <span class="o">=</span> <span class="n">join_index</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">flip_order</span><span class="p">:</span>
            <span class="n">left_indexer</span><span class="p">,</span> <span class="n">right_indexer</span> <span class="o">=</span> <span class="n">right_indexer</span><span class="p">,</span> <span class="n">left_indexer</span>

        <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
            <span class="n">left_indexer</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">left_indexer</span> <span class="ow">is</span> <span class="kc">None</span>
                            <span class="k">else</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">left_indexer</span><span class="p">))</span>
            <span class="n">right_indexer</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">right_indexer</span> <span class="ow">is</span> <span class="kc">None</span>
                             <span class="k">else</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">right_indexer</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">left_indexer</span><span class="p">,</span> <span class="n">right_indexer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">join_index</span>

    <span class="k">def</span> <span class="nf">_join_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">ret_index</span> <span class="o">=</span> <span class="n">other</span> <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span> <span class="k">else</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret_index</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret_index</span>

        <span class="n">sv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">ov</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="c1"># We can perform much better than the general case</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="n">lidx</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_indexer_unique</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="n">other</span>
                <span class="n">lidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_indexer_unique</span><span class="p">(</span><span class="n">ov</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
                <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outer_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">lidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_indexer</span><span class="p">(</span><span class="n">ov</span><span class="p">,</span> <span class="n">sv</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outer_indexer</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="n">ov</span><span class="p">)</span>
            <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_joined_index</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_indexers</span><span class="p">:</span>
            <span class="n">lidx</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">lidx</span><span class="p">)</span>
            <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_ensure_platform_int</span><span class="p">(</span><span class="n">ridx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">join_index</span>

    <span class="k">def</span> <span class="nf">_wrap_joined_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_string_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">use_lhs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_rhs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># this is for partial string indexing,</span>
        <span class="c1"># overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">slice_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For an ordered Index, compute the slice indexer for input labels and</span>
<span class="sd">        step</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : label, default None</span>
<span class="sd">            If None, defaults to the beginning</span>
<span class="sd">        end : label, default None</span>
<span class="sd">            If None, defaults to the end</span>
<span class="sd">        step : int, default None</span>
<span class="sd">        kind : string, default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indexer : ndarray or slice</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function assumes that the data is sorted, so use at your own peril</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_slice</span><span class="p">,</span> <span class="n">end_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_locs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                                                 <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>

        <span class="c1"># return a slice</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">start_slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Start slice bound is non-scalar&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">end_slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;End slice bound is non-scalar&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_slice</span><span class="p">,</span> <span class="n">end_slice</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we have a float key and are not a floating index</span>
<span class="sd">        then try to cast to an int if equivalent</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">is_float</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_floating</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ckey</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ckey</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">ckey</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">_validate_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if we are positional indexer</span>
<span class="sd">        validate that we have appropriate typed bounds</span>
<span class="sd">        must be an integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="s1">&#39;iloc&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;iloc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">_maybe_cast_slice_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should be overloaded in subclasses that allow non-trivial</span>
<span class="sd">        casting on label-slice bounds, e.g. datetime-like indices allowing</span>
<span class="sd">        strings containing formatted datetimes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}</span>
<span class="sd">        kind : {&#39;ix&#39;, &#39;loc&#39;, &#39;getitem&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        label :  object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Value of `side` parameter should be validated in caller.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># We are a plain index here (sub-class override this method if they</span>
        <span class="c1"># wish to have special treatment for floats/ints, e.g. Float64Index and</span>
        <span class="c1"># datetimelike Indexes</span>
        <span class="c1"># reject them</span>
        <span class="k">if</span> <span class="n">is_float</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ix&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">holds_integer</span><span class="p">()</span> <span class="ow">or</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">is_floating</span><span class="p">())):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="c1"># we are trying to find integer bounds on a non-integer based index</span>
        <span class="c1"># this is rejected (generally .loc gets you here)</span>
        <span class="k">elif</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid_indexer</span><span class="p">(</span><span class="s1">&#39;slice&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_searchsorted_monotonic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">:</span>
            <span class="c1"># np.searchsorted expects ascending sort order, have to reverse</span>
            <span class="c1"># everything for it to work (element ordering, search side and</span>
            <span class="c1"># resulting value).</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span>
                                          <span class="k">else</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;index must be monotonic increasing or decreasing&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_slice_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate slice bound that corresponds to given label.</span>

<span class="sd">        Returns leftmost (one-past-the-rightmost if ``side==&#39;right&#39;``) position</span>
<span class="sd">        of given label.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">        side : {&#39;left&#39;, &#39;right&#39;}</span>
<span class="sd">        kind : {&#39;ix&#39;, &#39;loc&#39;, &#39;getitem&#39;}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ix&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for side kwarg,&quot;</span>
                             <span class="s2">&quot; must be either &#39;left&#39; or &#39;right&#39;: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="p">))</span>

        <span class="n">original_label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="c1"># For datetime indices label may be a string that has to be converted</span>
        <span class="c1"># to datetime boundary according to its resolution.</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_cast_slice_bound</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>

        <span class="c1"># we need to look up the label</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searchsorted_monotonic</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># raise the original KeyError</span>
                <span class="k">raise</span> <span class="n">err</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># get_loc may return a boolean array or an array of indices, which</span>
            <span class="c1"># is OK as long as they are representable by a slice.</span>
            <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">slc</span><span class="p">):</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_booleans_to_slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;u1&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_indices_to_slice</span><span class="p">(</span><span class="n">slc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Cannot get </span><span class="si">%s</span><span class="s2"> slice bound for non-unique &quot;</span>
                               <span class="s2">&quot;label: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">original_label</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span><span class="o">.</span><span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slc</span>

    <span class="k">def</span> <span class="nf">slice_locs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute slice locations for input labels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : label, default None</span>
<span class="sd">            If None, defaults to the beginning</span>
<span class="sd">        end : label, default None</span>
<span class="sd">            If None, defaults to the end</span>
<span class="sd">        step : int, defaults None</span>
<span class="sd">            If None, defaults to 1</span>
<span class="sd">        kind : {&#39;ix&#39;, &#39;loc&#39;, &#39;getitem&#39;} or None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        start, end : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inc</span><span class="p">:</span>
            <span class="c1"># If it&#39;s a reverse slice, temporarily swap bounds.</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>

        <span class="n">start_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice_bound</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_slice</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">end_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice_bound</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_slice</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inc</span><span class="p">:</span>
            <span class="c1"># Bounds at this moment are swapped, swap them back and shift by 1.</span>
            <span class="c1">#</span>
            <span class="c1"># slice_locs(&#39;B&#39;, &#39;A&#39;, step=-1): s=&#39;B&#39;, e=&#39;A&#39;</span>
            <span class="c1">#</span>
            <span class="c1">#              s=&#39;A&#39;                 e=&#39;B&#39;</span>
            <span class="c1"># AFTER SWAP:    |                     |</span>
            <span class="c1">#                v ------------------&gt; V</span>
            <span class="c1">#           -----------------------------------</span>
            <span class="c1">#           | | |A|A|A|A| | | | | |B|B| | | | |</span>
            <span class="c1">#           -----------------------------------</span>
            <span class="c1">#              ^ &lt;------------------ ^</span>
            <span class="c1"># SHOULD BE:   |                     |</span>
            <span class="c1">#           end=s-1              start=e-1</span>
            <span class="c1">#</span>
            <span class="n">end_slice</span><span class="p">,</span> <span class="n">start_slice</span> <span class="o">=</span> <span class="n">start_slice</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end_slice</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># i == -1 triggers ``len(self) + i`` selection that points to the</span>
            <span class="c1"># last element, not before-the-first one, subtracting len(self)</span>
            <span class="c1"># compensates that.</span>
            <span class="k">if</span> <span class="n">end_slice</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">end_slice</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_slice</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">start_slice</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">start_slice</span><span class="p">,</span> <span class="n">end_slice</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index with passed location(-s) deleted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index inserting new item at location. Follows</span>
<span class="sd">        Python list.append semantics for negative values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">        item : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_self</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coerce_scalar_to_index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">_self</span><span class="p">[:</span><span class="n">loc</span><span class="p">],</span> <span class="n">item</span><span class="p">,</span> <span class="n">_self</span><span class="p">[</span><span class="n">loc</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy_with_infer</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index with passed list of labels deleted</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : array-like</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_index_labels_to_array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">errors</span> <span class="o">!=</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;labels </span><span class="si">%s</span><span class="s1"> not contained in axis&#39;</span> <span class="o">%</span>
                                 <span class="n">labels</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">indexer</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;unique&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="s1">&#39;take_last&#39;</span><span class="p">,</span> <span class="s1">&#39;keep&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;last&#39;</span><span class="p">,</span>
                                                   <span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">})</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;drop_duplicates&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="s1">&#39;take_last&#39;</span><span class="p">,</span> <span class="s1">&#39;keep&#39;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;last&#39;</span><span class="p">,</span>
                                                   <span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;first&#39;</span><span class="p">})</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;duplicated&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_index_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;fillna&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Fill NA/NaN values with the specified value</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        value : scalar</span>
<span class="s2">            Scalar value to use to fill holes (e.g. 0).</span>
<span class="s2">            This value cannot be a list-likes.</span>
<span class="s2">        downcast : dict, default is None</span>
<span class="s2">            a dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="s2">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="s2">            equal type (e.g. float64 to int64 if possible)</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        filled : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;fillna&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_can_do_op</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">downcast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># no need to care metadata other than name</span>
                <span class="c1"># because it can&#39;t have freq if</span>
                <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>

    <span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;dropna&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return Index without NA/NaN values</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        how :  {&#39;any&#39;, &#39;all&#39;}, default &#39;any&#39;</span>
<span class="s2">            If the Index is a MultiIndex, drop the value when any or all levels</span>
<span class="s2">            are NaN.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        valid : Index</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_index_shared_docs</span><span class="p">[</span><span class="s1">&#39;dropna&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">how</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid how option: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">how</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_isnan</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_evaluate_with_timedelta_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only perform ops with timedelta like values&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evaluate_with_datetime_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only perform ops with datetime like values&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_evalute_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">base</span><span class="o">.</span><span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_comparison_methods</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in comparison methods &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_compare</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_evaluate_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lengths must match to compare&#39;</span><span class="p">)</span>

                <span class="c1"># we may need to directly compare underlying</span>
                <span class="c1"># representations</span>
                <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># don&#39;t pass MultiIndex</span>
                    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">_comp_method_OBJECT_ARRAY</span><span class="p">(</span>
                            <span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

                <span class="c1"># technically we could support bool dtyped Index</span>
                <span class="c1"># for now just return the indexing array directly</span>
                <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span>

            <span class="k">return</span> <span class="n">_evaluate_compare</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__eq__</span> <span class="o">=</span> <span class="n">_make_compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__ne__</span> <span class="o">=</span> <span class="n">_make_compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__lt__</span> <span class="o">=</span> <span class="n">_make_compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__gt__</span> <span class="o">=</span> <span class="n">_make_compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__le__</span> <span class="o">=</span> <span class="n">_make_compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__ge__</span> <span class="o">=</span> <span class="n">_make_compare</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_methods_add_sub_disabled</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in the numeric add/sub methods to disable &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_invalid_op</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">invalid_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot perform </span><span class="si">{name}</span><span class="s2"> with this index type: &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

            <span class="n">invalid_op</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">invalid_op</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__add__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__radd__</span> <span class="o">=</span> <span class="n">__iadd__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">)</span>  <span class="c1"># noqa</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__sub__</span> <span class="o">=</span> <span class="n">__isub__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">)</span>  <span class="c1"># noqa</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_methods_disabled</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in numeric methods to disable other than add/sub &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_invalid_op</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">invalid_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot perform </span><span class="si">{name}</span><span class="s2"> with this index type: &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

            <span class="n">invalid_op</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">invalid_op</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__pow__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rpow__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__mul__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rmul__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__floordiv__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rfloordiv__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__floordiv__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__truediv__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rtruediv__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__div__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rdiv__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__div__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__neg__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__neg__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__pos__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__pos__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__abs__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__abs__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__inv__</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;__inv__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_update_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update Index attributes (e.g. freq) depending on op &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="k">def</span> <span class="nf">_validate_for_numeric_unaryop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; validate if we can perform a numeric unary operation &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric_dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate a numeric op &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{opstr}</span><span class="s2"> for type: </span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">opstr</span><span class="o">=</span><span class="n">opstr</span><span class="p">,</span>
                                <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_for_numeric_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return valid other, evaluate or raise TypeError</span>
<span class="sd">        if we are not of the appropriate type</span>

<span class="sd">        internal method called by ops</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.offsets</span> <span class="k">import</span> <span class="n">DateOffset</span>

        <span class="c1"># if we are an inheritor of numeric,</span>
        <span class="c1"># but not actually numeric (e.g. DatetimeIndex/PeriodInde)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric_dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate a numeric op </span><span class="si">{opstr}</span><span class="s2"> &quot;</span>
                            <span class="s2">&quot;for type: </span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">opstr</span><span class="o">=</span><span class="n">opstr</span><span class="p">,</span>
                                <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_numeric_dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate a numeric op &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{opstr}</span><span class="s2"> with type: </span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">opstr</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                    <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate a numeric op with &quot;</span>
                                 <span class="s2">&quot;unequal lengths&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot evaluate a numeric op &quot;</span>
                                <span class="s2">&quot;with a non-numeric dtype&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">DateOffset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">,</span>
                                <span class="n">Timedelta</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">)):</span>
            <span class="c1"># higher up to handle</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)):</span>
            <span class="c1"># higher up to handle</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_float</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;can only perform ops with scalar values&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">other</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_methods_binary</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in numeric methods &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_evaluate_binop</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="n">Index</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_evaluate_numeric_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

                <span class="kn">from</span> <span class="nn">pandas.tseries.offsets</span> <span class="k">import</span> <span class="n">DateOffset</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_for_numeric_binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">)</span>

                <span class="c1"># handle time-based others</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">DateOffset</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">,</span>
                                      <span class="n">Timedelta</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_with_timedelta_like</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Timestamp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_with_datetime_like</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">)</span>

                <span class="c1"># if we are a reversed non-communative op</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
                <span class="k">if</span> <span class="nb">reversed</span><span class="p">:</span>
                    <span class="n">values</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="n">values</span>

                <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_attributes</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_evaluate_numeric_binop</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__add__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__radd__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;__add__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__sub__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;__sub__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__rsub__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="s1">&#39;__sub__&#39;</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__mul__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rmul__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;__mul__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__pow__</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__rpow__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="s1">&#39;__pow__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__mod__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="s1">&#39;__mod__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__floordiv__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="s1">&#39;__floordiv__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__rfloordiv__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="s1">&#39;__floordiv__&#39;</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__truediv__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="s1">&#39;__truediv__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__rtruediv__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="s1">&#39;__truediv__&#39;</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__div__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="s1">&#39;__div__&#39;</span><span class="p">)</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__rdiv__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
                <span class="n">operator</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="s1">&#39;__div__&#39;</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__divmod__</span> <span class="o">=</span> <span class="n">_make_evaluate_binop</span><span class="p">(</span>
            <span class="nb">divmod</span><span class="p">,</span>
            <span class="s1">&#39;__divmod__&#39;</span><span class="p">,</span>
            <span class="n">constructor</span><span class="o">=</span><span class="k">lambda</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">attrs</span><span class="p">),</span>
                <span class="n">Index</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">attrs</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_methods_unary</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in numeric unary methods &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_evaluate_unary</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">_evaluate_numeric_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_validate_for_numeric_unaryop</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">opstr</span><span class="p">)</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_attributes_dict</span><span class="p">()</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_attributes</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_evaluate_numeric_unary</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__neg__</span> <span class="o">=</span> <span class="n">_make_evaluate_unary</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__neg__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__pos__</span> <span class="o">=</span> <span class="n">_make_evaluate_unary</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__pos__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__abs__</span> <span class="o">=</span> <span class="n">_make_evaluate_unary</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span> <span class="s1">&#39;__abs__&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__inv__</span> <span class="o">=</span> <span class="n">_make_evaluate_unary</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__inv__&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_methods</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_add_numeric_methods_unary</span><span class="p">()</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_add_numeric_methods_binary</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_logical_methods</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in logical methods &quot;&quot;&quot;</span>

        <span class="n">_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">        </span><span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        All arguments to numpy.</span><span class="si">%(outname)s</span><span class="s2"> are accepted.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        </span><span class="si">%(outname)s</span><span class="s2"> : bool or array_like (if axis is specified)</span>
<span class="s2">            A single element array_like may be converted to bool.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_logical_function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
            <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
            <span class="nd">@Appender</span><span class="p">(</span><span class="n">_doc</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">logical_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">Index</span><span class="p">))</span> <span class="ow">and</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># return NumPy type</span>
                    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">return</span> <span class="n">result</span>

            <span class="n">logical_func</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">logical_func</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">all</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;Return whether all elements &#39;</span>
                                                <span class="s1">&#39;are True&#39;</span><span class="p">,</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">any</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;Return whether any element is True&#39;</span><span class="p">,</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_logical_methods_disabled</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add in logical methods to disable &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_make_invalid_op</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">invalid_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot perform </span><span class="si">{name}</span><span class="s2"> with this index type: &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

            <span class="n">invalid_op</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">return</span> <span class="n">invalid_op</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">all</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">any</span> <span class="o">=</span> <span class="n">_make_invalid_op</span><span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">)</span>


<span class="n">Index</span><span class="o">.</span><span class="n">_add_numeric_methods_disabled</span><span class="p">()</span>
<span class="n">Index</span><span class="o">.</span><span class="n">_add_logical_methods</span><span class="p">()</span>
<span class="n">Index</span><span class="o">.</span><span class="n">_add_comparison_methods</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_ensure_index</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">index_like</span> <span class="o">=</span> <span class="n">index_like</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">index_like</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">index_like</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="c1"># must check for exactly list here because of strict type</span>
    <span class="c1"># check in clean_index_list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_like</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">index_like</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>
        <span class="c1"># 2200 ?</span>
        <span class="n">converted</span><span class="p">,</span> <span class="n">all_arrays</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">clean_index_list</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">converted</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">all_arrays</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.multi</span> <span class="k">import</span> <span class="n">MultiIndex</span>
            <span class="k">return</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">converted</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_like</span> <span class="o">=</span> <span class="n">converted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># clean_index_list does the equivalent of copying</span>
        <span class="c1"># so only need to do this if not list instance</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">copy</span>
            <span class="n">index_like</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Index</span><span class="p">(</span><span class="n">index_like</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_na_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">:</span> <span class="n">tslib</span><span class="o">.</span><span class="n">NaT</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">:</span> <span class="n">tslib</span><span class="o">.</span><span class="n">NaT</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ensure_frozen</span><span class="p">(</span><span class="n">array_like</span><span class="p">,</span> <span class="n">categories</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">array_like</span> <span class="o">=</span> <span class="n">_coerce_indexer_dtype</span><span class="p">(</span><span class="n">array_like</span><span class="p">,</span> <span class="n">categories</span><span class="p">)</span>
    <span class="n">array_like</span> <span class="o">=</span> <span class="n">array_like</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">FrozenNDArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">array_like</span> <span class="o">=</span> <span class="n">array_like</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array_like</span>


<span class="k">def</span> <span class="nf">_ensure_has_len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If seq is an iterator, put its values into a list.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seq</span>


<span class="k">def</span> <span class="nf">_trim_front</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trims zeros and decimal points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trimmed</span> <span class="o">=</span> <span class="n">strings</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trimmed</span><span class="p">]):</span>
        <span class="n">trimmed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trimmed</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">trimmed</span>


<span class="k">def</span> <span class="nf">_validate_join_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;do not recognize join method </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../testcases.html">Test cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Credits</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Dheepak Krishnamurthy.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>